---
title: Creating this site
description: SvelteKit + Markdown static site & blog
date: '2025-12-31'
categories:
  - sveltekit
  - svelte
  - frontend
  - web dev
published: true
---

I created this personal site as a way of documenting all that I was learning and building. Along the way, I learned about SvelteKit and TypeScript, including how to preprocess and dynamically render blog posts like this one. I deployed the site to GitHub Pages, where you're now able to read it. 

## The Very Basics of Frontend Development
At its most basic, a static site just consists of HTML (for the content of the site) and CSS (for the styling). They're stored as HTML documents, and accessed by a web server through an HTTP connection to be displayed on a browser client. There exists a variety of tools and frameworks that aim to make managing large and complex websites easier, and to answer the question of where HTML gets generated. 

To clarify the client-server architecture models, there are two main approaches to rendering: server-side rendering and client-side rendering. 
- In **server-side rendering**, the browser requests a URL, the web server responds with HTML, and the browser renders it - the HTML is fully generated by the server. 
- In **client-side rendering**, the server sends minimal HTML with a JavaScript bundle, the browser downloads JavaScript, and the final webpage is generated on the client side by that bundle.

This makes a difference to the end user, since it can affect the initial loading time (where SSR is faster) as well as the reactivity (where CSR has the advantage). 

Before we even get to rendering, though, there's also a distinction to be made between build time and runtime. 
- **Build time**: before any rendering can happen, all code needs to be compiled into executable JavaScript. 
- **Runtime**: when a user visits the site, content is rendered, either on the server side or client side as defined above. Runtime rendering is when SSR/CSR come into play.

With frameworks like SvelteKit (or React), we can use a hybrid of these approaches, as well as take advantage of pre-built components and optimizations for fast loading. SvelteKit, by default, renders a component first on the server side, then 'hydrates' it on the client side to allow for reactivity. For pages that can be represented as simple HTML files at build time, we can set `prerender=true`, which means it doesn't need to be rendered again on the server or client side at runtime.

## Using Svelte & SvelteKit
This site was built using Svelte, SvelteKit, and Markdown for these blog posts. Each of these are responsible for a different part of the stack, explained well in the [Svelte](https://svelte.dev/docs/kit/introduction) and [mdsvex](https://github.com/pngwn/MDsveX) docs. Here's a summary:
- **Svelte** is the UI framework, defining component `.svelte` files. It converts components to JavaScript which renders the HTML/CSS, and handles reactivity, events, and rendering.
- **SvelteKit** is the application framework, providing the structure for the website or web app. It adds the data and logic to Svelte, including support for routers, SSR/CSR, and various optimizations. It operates on `.js` or `.ts` files, which fetch/prepare data before it is injected into `.svelte` components for rendering.

I found the most interesting part to be the way that blog posts are rendered. Blog posts all follow the same format - title, date, content - and thus can be stored as markdown files. In order to integrate markdown into the SvelteKit setup, I used mdsvex, which preprocesses `.md` files and turns them into Svelte components - I followed [this guide](https://joyofcode.xyz/sveltekit-markdown-blog). Rather than hard-coding posts, we can add posts simply by adding a new markdown file. These posts are all discovered by a globbing pattern and turned into data, exposed at the `api/posts` route. This data is rendered at `/writing/[post-name]` - the slug `[post-name]` is matched to the URL, and the corresponding markdown file renders it. These dynamics routes are a runtime concept - when a request comes in (a user visits the site), we load the markdown file and send a response.

There are some restrictions as to what content can be prerendered (compiled to HTML at build time). According to the [docs](https://svelte.dev/docs/kit/page-options#prerender-When-not-to-prerender), "The basic rule is this: for a page to be prerenderable, any two users hitting it directly must get the same content from the server." Our blog posts, then, which only use parameters known at build time, can be prerendered. The prerenderer works by starting at the root of the app and crawling the files, generating HTML for all prerenderable pages and scanning each one for `<a>` elements pointing to other pages. Note that we need to explicitly specify all possible parameter values for our dynamic slug so that the prerenderer knows the routes for which it must generate HTML - otherwise, we'll run into an error like the following: `/writing/[slug] was marked prerenderable, but was not found while crawling`.

The overall model I've clarified is markdown files -> modules -> data -> UI.

## Deploying to GitHub Sites
Next is deploying the site - once we create the SvelteKit web app, it needs to be made available on the internet. I deployed the site on GitHub Pages, which hosts static sites - sites that don't require any server-side functionality. I use a basic GitHub Actions workflow to build the site - it installs dependencies, builds the site, and uploads the artifacts to blob storage. Finally, the artifacts are fetched and deployed to emma-x1.github.io/, where you're seeing this now.

## Conclusion
Overall, I was able to learn a lot about frontend and full stack development through creating this site. All of the source code is available at [this repo](https://github.com/emma-x1/emma-x1.github.io), and I'm hoping to continue to update and improve it.
