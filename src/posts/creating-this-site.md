---
title: Creating this site
description: SvelteKit + Markdown static site & blog
date: '2025-12-31'
categories:
  - sveltekit 
  - svelte
published: true
---

I created this personal site as a way of documenting all that I was learning and building. Along the way, I learned about SvelteKit and TypeScript, including to preprocess and dynamically render blog posts like this one. I deployed the site to GitHub sites, where you're now able to read it. 

## The Very Basics of Frontend Development
At its most basic, a static site just consists of HTML (for the content of the site) and CSS (for the styling). They're stored as HTML documents, and accessed by a web server through an HTTP connection to be displayed on a browser client. There exists a variety of tools and frameworks that aim to make managing large and complex websites easier, and to answer the question of where HTML gets generated. 

To clarify the client-server architecture models, there are two main approaches to rendering: server-side rendering and client-side rendering. 
- In **server-side rendering**, the browser requests a URL, the web server responds with HTML, and the browser renders it - the HTML is fully generated by the server. 
- In **client-side rendering**, the server sends minimal HTML with a JavaScript bundle, the browser downloads JavaScript, and the final webpage is generated on the client side using that bundle.
This makes a difference to the end user, since it can affect the initial loading time (where SSR is faster) as well as the reactivity (where CSR has the advantage). 

Before we even get to rendering, though, there's also a distinction to be made between build time and runtime. 
- Build time: before any rendering can happen, all code needs to be compiled, or turned into executable JavaScript. 
- Runtime: when a user visits the site, content is rendered, either on the server side or client side as defined above.

With frameworks like SvelteKit (or React), we can use a hybrid of these approaches, as well as take advantage of pre-built components and optimizations for fast loading. SvelteKit, by default, renders a component first on the server side, then 'hydrates' it on the client side to allow for reactivity. For pages that can be represented as simple HTML files at build time, we can set `prerender=true`, which means it doesn't need to be rendered again on the server or client side at runtime.

## Using Svelte & SvelteKit
This site was built using Svelte, SvelteKit, and Markdown for these blog posts. Each of these are responsible for a different part of the stack, explained well in the [Svelte](https://svelte.dev/docs/kit/introduction) and [mdsvex](https://github.com/pngwn/MDsveX) docs. Here's a summary:
- **Svelte** is the UI framework, defining component `.svelte` files. It converts components to JavaScript which renders the HTML/CSS, and handles reactivity, events, and rendering.
- **SvelteKit** is the application framework, providing the structure for the website or web app. It adds the data and logic to Svelte, including support for routers, SSR/CSR, and various optimizations. It operates on `.js` or `.ts` files, which fetch/prepare data before it can be injected into the `.svelte` files to be rendered.

I found the most interesting part to be the way that blog posts are rendered. Blog posts all follow the same format - title, date, content - and thus can be stored as markdown files. In order to integrate markdown into the SvelteKit setup, I used mdsvex, which preprocesses `.md` files and turns them into Svelte components - I followed [this guide](https://joyofcode.xyz/sveltekit-markdown-blog). Rather than hard-coding posts, we can add posts simply by adding a new markdown file, and they are all discovered by a globbing pattern and turned into data, exposed at the `api/posts` route. This data is rendered at `/writing/[post-name]` - `[post-name]` is matched to the URL, and the corresponding markdown file is renders it. These dynamics routes are a runtime concept - when a request comes in (a user visits the site), we load the markdown file and send a response.

There are some restrictions as to what content can be prerendered (compiled to HTML at build time). 

The overall model I've clarified is markdown files -> modules -> data -> UI.

## Deploying to GitHub Sites
Next is deploying the site - once we create the SvelteKit web app, it needs to be made available on the internet. I deployed the site on GitHub Pages, which 

## Conclusion
Overall, I was able to learn a lot about frontend and full stack development through creating this site. All of the source code is available at [this repo](https://github.com/emma-x1/emma-x1.github.io), and I'm hoping to continue to update and improve it.
